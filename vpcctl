#!/usr/bin/env python3
"""
vpcctl - Virtual Private Cloud Control Tool
A complete implementation of VPC functionality using Linux networking primitives

This tool allows you to:
- Create isolated virtual private clouds (VPCs)
- Manage public and private subnets
- Configure NAT gateways for internet access
- Establish VPC peering connections
- Apply firewall policies (security groups)
- Deploy and test applications

Author: Ubah Delight Okechukwu
Date: November 2025
"""

import json
import subprocess
import sys
import os
import argparse
import logging
from pathlib import Path
from datetime import datetime
import ipaddress

# Configuration
HOME = Path.home()
STATE_DIR = HOME / ".vpcctl"
LOG_DIR = STATE_DIR / "logs"
STATE_FILE = STATE_DIR / "vpc_state.json"

# Create directories
LOG_DIR.mkdir(parents=True, exist_ok=True)
STATE_DIR.mkdir(parents=True, exist_ok=True)

# Setup logging
log_file = LOG_DIR / f"vpcctl_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

print("=" * 80)
print("  VPCCTL - Virtual Private Cloud Control Tool")
print("  Building VPCs from Linux Networking Primitives")
print("=" * 80)
logger.info("vpcctl started")


class VPCState:
    """
    Manages VPC state persistence to disk
    
    State is stored in JSON format at ~/.vpcctl/vpc_state.json
    This allows VPC configurations to persist across reboots
    """
    
    def __init__(self):
        self.state = self.load()
    
    def load(self):
        """Load VPC state from disk"""
        if STATE_FILE.exists():
            try:
                with open(STATE_FILE, 'r') as f:
                    return json.load(f)
            except json.JSONDecodeError:
                logger.warning("Corrupted state file, starting fresh")
                return {"vpcs": {}}
        return {"vpcs": {}}
    
    def save(self):
        """Save VPC state to disk"""
        with open(STATE_FILE, 'w') as f:
            json.dump(self.state, f, indent=2)
        logger.info(f"State saved to {STATE_FILE}")
    
    def add_vpc(self, vpc_name, vpc_config):
        """Add VPC to state"""
        self.state["vpcs"][vpc_name] = vpc_config
        self.save()
    
    def remove_vpc(self, vpc_name):
        """Remove VPC from state"""
        if vpc_name in self.state["vpcs"]:
            del self.state["vpcs"][vpc_name]
            self.save()
    
    def get_vpc(self, vpc_name):
        """Get VPC configuration"""
        return self.state["vpcs"].get(vpc_name)
    
    def list_vpcs(self):
        """List all VPCs"""
        return self.state["vpcs"]
    
    def update_vpc(self, vpc_name, vpc_config):
        """Update VPC configuration"""
        self.state["vpcs"][vpc_name] = vpc_config
        self.save()


class NetworkManager:
    """
    Handles low-level Linux networking operations
    
    This class wraps Linux networking commands (ip, iptables)
    and provides a clean interface for VPC operations
    """
    
    @staticmethod
    def run_command(cmd, check=True, capture=True):
        """Execute shell command with error handling"""
        cmd_str = ' '.join(cmd) if isinstance(cmd, list) else cmd
        logger.info(f"Executing: {cmd_str}")
        try:
            if capture:
                result = subprocess.run(cmd, check=check, capture_output=True, text=True)
                if result.stdout:
                    logger.debug(f"Output: {result.stdout.strip()}")
                return result
            else:
                subprocess.run(cmd, check=check)
                return None
        except subprocess.CalledProcessError as e:
            logger.error(f"Command failed: {cmd_str}")
            if hasattr(e, 'stderr') and e.stderr:
                logger.error(f"Error: {e.stderr}")
            if check:
                raise
            return None
    
    @staticmethod
    def create_namespace(ns_name):
        """Create network namespace (isolated network environment)"""
        logger.info(f"Creating namespace: {ns_name}")
        NetworkManager.run_command(["ip", "netns", "add", ns_name])
        print(f"  ‚úì Created namespace: {ns_name}")
    
    @staticmethod
    def delete_namespace(ns_name):
        """Delete network namespace"""
        logger.info(f"Deleting namespace: {ns_name}")
        NetworkManager.run_command(["ip", "netns", "del", ns_name], check=False)
        print(f"  ‚úì Deleted namespace: {ns_name}")
    
    @staticmethod
    def create_bridge(bridge_name):
        """Create Linux bridge (acts as virtual switch/router)"""
        logger.info(f"Creating bridge: {bridge_name}")
        NetworkManager.run_command(["ip", "link", "add", bridge_name, "type", "bridge"])
        NetworkManager.run_command(["ip", "link", "set", bridge_name, "up"])
        print(f"  ‚úì Created bridge: {bridge_name}")
    
    @staticmethod
    def delete_bridge(bridge_name):
        """Delete Linux bridge"""
        logger.info(f"Deleting bridge: {bridge_name}")
        NetworkManager.run_command(["ip", "link", "set", bridge_name, "down"], check=False)
        NetworkManager.run_command(["ip", "link", "del", bridge_name], check=False)
        print(f"  ‚úì Deleted bridge: {bridge_name}")
    
    @staticmethod
    def create_veth_pair(veth_name, peer_name):
        """Create veth pair (virtual ethernet cable)"""
        logger.info(f"Creating veth pair: {veth_name} <-> {peer_name}")
        NetworkManager.run_command(["ip", "link", "add", veth_name, "type", "veth", "peer", "name", peer_name])
        print(f"  ‚úì Created veth pair: {veth_name} <-> {peer_name}")
    
    @staticmethod
    def delete_veth(veth_name):
        """Delete veth interface"""
        logger.info(f"Deleting veth: {veth_name}")
        NetworkManager.run_command(["ip", "link", "del", veth_name], check=False)
    
    @staticmethod
    def attach_to_bridge(interface, bridge):
        """Attach network interface to bridge"""
        logger.info(f"Attaching {interface} to bridge {bridge}")
        NetworkManager.run_command(["ip", "link", "set", interface, "master", bridge])
        NetworkManager.run_command(["ip", "link", "set", interface, "up"])
    
    @staticmethod
    def move_to_namespace(interface, namespace):
        """Move network interface to namespace"""
        logger.info(f"Moving {interface} to namespace {namespace}")
        NetworkManager.run_command(["ip", "link", "set", interface, "netns", namespace])
    
    @staticmethod
    def set_ip_address(namespace, interface, ip_cidr):
        """Set IP address on interface in namespace"""
        logger.info(f"Setting IP {ip_cidr} on {interface} in namespace {namespace}")
        NetworkManager.run_command(["ip", "netns", "exec", namespace, "ip", "addr", "add", ip_cidr, "dev", interface])
        NetworkManager.run_command(["ip", "netns", "exec", namespace, "ip", "link", "set", interface, "up"])
        NetworkManager.run_command(["ip", "netns", "exec", namespace, "ip", "link", "set", "lo", "up"])
    
    @staticmethod
    def add_route(namespace, destination, gateway):
        """Add route in namespace"""
        logger.info(f"Adding route in {namespace}: {destination} via {gateway}")
        NetworkManager.run_command(["ip", "netns", "exec", namespace, "ip", "route", "add", destination, "via", gateway])
    
    @staticmethod
    def add_host_route(destination, via_bridge):
        """Add route on host (for VPC peering)"""
        logger.info(f"Adding host route: {destination} dev {via_bridge}")
        # Check if route already exists
        result = NetworkManager.run_command(["ip", "route", "show", destination], check=False)
        if result and destination in result.stdout:
            logger.info(f"Route to {destination} already exists, skipping")
            return
        NetworkManager.run_command(["ip", "route", "add", destination, "dev", via_bridge])
    
    @staticmethod
    def delete_host_route(destination):
        """Delete route from host"""
        logger.info(f"Deleting host route: {destination}")
        NetworkManager.run_command(["ip", "route", "del", destination], check=False)
    
    @staticmethod
    def enable_ip_forward():
        """Enable IP forwarding (required for routing between networks)"""
        logger.info("Enabling IP forwarding")
        NetworkManager.run_command(["sysctl", "-w", "net.ipv4.ip_forward=1"], capture=False)
    
    @staticmethod
    def setup_nat(bridge_name, subnet_cidr, out_interface):
        """
        Setup NAT (Network Address Translation) for internet access
        This allows private IPs to access the internet through the host
        """
        logger.info(f"Setting up NAT for {subnet_cidr} via {out_interface}")
        
        # MASQUERADE rule - translates private IPs to host's public IP
        NetworkManager.run_command([
            "iptables", "-t", "nat", "-A", "POSTROUTING",
            "-s", subnet_cidr, "-o", out_interface, "-j", "MASQUERADE"
        ])
        
        # Forward rules - allow traffic through the host
        NetworkManager.run_command([
            "iptables", "-A", "FORWARD", "-i", bridge_name,
            "-o", out_interface, "-j", "ACCEPT"
        ])
        NetworkManager.run_command([
            "iptables", "-A", "FORWARD", "-i", out_interface,
            "-o", bridge_name, "-m", "state", "--state",
            "RELATED,ESTABLISHED", "-j", "ACCEPT"
        ])
        print(f"  ‚úì NAT configured for {subnet_cidr}")
    
    @staticmethod
    def remove_nat(subnet_cidr, out_interface):
        """Remove NAT rules"""
        logger.info(f"Removing NAT for {subnet_cidr}")
        NetworkManager.run_command([
            "iptables", "-t", "nat", "-D", "POSTROUTING",
            "-s", subnet_cidr, "-o", out_interface, "-j", "MASQUERADE"
        ], check=False)
    
    @staticmethod
    def apply_firewall_rule(namespace, rule):
        """Apply iptables firewall rule in namespace"""
        protocol = rule.get("protocol", "tcp")
        port = rule.get("port")
        action = rule.get("action", "allow").upper()
        
        target = "ACCEPT" if action == "ALLOW" else "DROP"
        
        logger.info(f"Applying firewall rule in {namespace}: {action} {protocol}/{port}")
        
        cmd = ["ip", "netns", "exec", namespace, "iptables", "-A", "INPUT",
               "-p", protocol]
        
        if port:
            cmd.extend(["--dport", str(port)])
        
        cmd.extend(["-j", target])
        
        NetworkManager.run_command(cmd)
        print(f"  ‚úì Applied rule: {action} {protocol}/{port}")


class VPCManager:
    """
    High-level VPC management operations
    
    This class orchestrates all VPC operations by using NetworkManager
    for low-level networking and VPCState for persistence
    """
    
    def __init__(self):
        self.state = VPCState()
        self.net = NetworkManager()
    
    def create_vpc(self, vpc_name, cidr_block):
        """
        Create a new VPC
        
        A VPC is implemented as:
        - A Linux bridge (acts as the VPC router)
        - IP address space defined by CIDR block
        - Isolated from other VPCs by default
        """
        print(f"\n{'='*80}")
        print(f"CREATING VPC: {vpc_name}")
        print(f"{'='*80}")
        logger.info(f"Creating VPC: {vpc_name} with CIDR: {cidr_block}")
        
        # Validate CIDR
        try:
            network = ipaddress.ip_network(cidr_block)
        except ValueError as e:
            print(f"‚ùå Error: Invalid CIDR block: {e}")
            logger.error(f"Invalid CIDR block: {e}")
            return False
        
        # Check if VPC already exists
        if self.state.get_vpc(vpc_name):
            print(f"‚ùå Error: VPC '{vpc_name}' already exists")
            logger.error(f"VPC {vpc_name} already exists")
            return False
        
        bridge_name = f"br-{vpc_name}"
        
        try:
            # Create bridge
            self.net.create_bridge(bridge_name)
            
            # Assign bridge IP (first usable IP in VPC range)
            bridge_ip = str(list(network.hosts())[0])
            self.net.run_command(["ip", "addr", "add", f"{bridge_ip}/{network.prefixlen}", "dev", bridge_name])
            print(f"  ‚úì Assigned bridge IP: {bridge_ip}/{network.prefixlen}")
            
            # Enable IP forwarding
            self.net.enable_ip_forward()
            
            # Save VPC state
            vpc_config = {
                "name": vpc_name,
                "cidr_block": cidr_block,
                "bridge": bridge_name,
                "bridge_ip": bridge_ip,
                "subnets": {},
                "peerings": [],
                "created_at": datetime.now().isoformat()
            }
            
            self.state.add_vpc(vpc_name, vpc_config)
            
            print(f"\n‚úÖ VPC '{vpc_name}' created successfully!")
            print(f"   CIDR Block: {cidr_block}")
            print(f"   Bridge: {bridge_name}")
            print(f"   Gateway IP: {bridge_ip}")
            logger.info(f"VPC {vpc_name} created successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Error: Failed to create VPC: {e}")
            logger.error(f"Failed to create VPC: {e}")
            self.net.delete_bridge(bridge_name)
            return False
    
    def add_subnet(self, vpc_name, subnet_name, subnet_cidr, subnet_type="private"):
        """
        Add subnet to VPC
        
        Subnet implementation:
        - Network namespace (isolated network environment)
        - veth pair connects namespace to VPC bridge
        - Public subnets have NAT for internet access
        - Private subnets are isolated from internet
        """
        print(f"\n{'='*80}")
        print(f"ADDING SUBNET: {subnet_name} to VPC: {vpc_name}")
        print(f"{'='*80}")
        logger.info(f"Adding subnet {subnet_name} ({subnet_cidr}) to VPC {vpc_name}")
        
        vpc = self.state.get_vpc(vpc_name)
        if not vpc:
            print(f"‚ùå Error: VPC '{vpc_name}' not found")
            logger.error(f"VPC {vpc_name} not found")
            return False
        
        # Validate subnet CIDR is within VPC CIDR
        try:
            vpc_network = ipaddress.ip_network(vpc["cidr_block"])
            subnet_network = ipaddress.ip_network(subnet_cidr)
            
            if not subnet_network.subnet_of(vpc_network):
                print(f"‚ùå Error: Subnet {subnet_cidr} is not within VPC {vpc['cidr_block']}")
                logger.error(f"Subnet {subnet_cidr} is not within VPC {vpc['cidr_block']}")
                return False
        except ValueError as e:
            print(f"‚ùå Error: Invalid CIDR: {e}")
            logger.error(f"Invalid CIDR: {e}")
            return False
        
        # Check if subnet exists
        if subnet_name in vpc["subnets"]:
            print(f"‚ùå Error: Subnet '{subnet_name}' already exists")
            logger.error(f"Subnet {subnet_name} already exists")
            return False
        
        namespace = f"ns-{vpc_name}-{subnet_name}"
        veth_host = f"veth-{subnet_name}"
        veth_ns = f"veth-{subnet_name}-ns"
        
        try:
            # Create namespace
            self.net.create_namespace(namespace)
            
            # Create veth pair
            self.net.create_veth_pair(veth_host, veth_ns)
            
            # Attach host side to bridge
            self.net.attach_to_bridge(veth_host, vpc["bridge"])
            print(f"  ‚úì Attached {veth_host} to {vpc['bridge']}")
            
            # Move namespace side to namespace
            self.net.move_to_namespace(veth_ns, namespace)
            
            # Assign IPs: Bridge gets first IP, namespace gets second IP
            bridge_subnet_ip = str(list(subnet_network.hosts())[0])
            self.net.run_command(["ip", "addr", "add", f"{bridge_subnet_ip}/{subnet_network.prefixlen}", "dev", vpc["bridge"]])
            print(f"  ‚úì Assigned {bridge_subnet_ip} to bridge on subnet {subnet_cidr}")
            
            subnet_ip = str(list(subnet_network.hosts())[1])
            self.net.set_ip_address(namespace, veth_ns, f"{subnet_ip}/{subnet_network.prefixlen}")
            print(f"  ‚úì Assigned IP {subnet_ip} to {namespace}")
            
            # Default route via bridge IP on this subnet
            self.net.add_route(namespace, "default", bridge_subnet_ip)
            print(f"  ‚úì Added default route via {bridge_subnet_ip}")
            
            # Setup NAT if public subnet
            out_interface = None
            if subnet_type == "public":
                out_interface = self.get_default_interface()
                self.net.setup_nat(vpc["bridge"], str(subnet_network), out_interface)
            
            # Update state
            vpc["subnets"][subnet_name] = {
                "name": subnet_name,
                "cidr": subnet_cidr,
                "type": subnet_type,
                "namespace": namespace,
                "veth_host": veth_host,
                "veth_ns": veth_ns,
                "ip": subnet_ip,
                "bridge_ip": bridge_subnet_ip,
                "out_interface": out_interface,
                "created_at": datetime.now().isoformat()
            }
            
            self.state.update_vpc(vpc_name, vpc)
            
            print(f"\n‚úÖ Subnet '{subnet_name}' added successfully!")
            print(f"   CIDR: {subnet_cidr}")
            print(f"   Type: {subnet_type}")
            print(f"   IP Address: {subnet_ip}")
            print(f"   Gateway: {bridge_subnet_ip}")
            print(f"   Namespace: {namespace}")
            if subnet_type == "public":
                print(f"   NAT: Enabled via {out_interface}")
            
            logger.info(f"Subnet {subnet_name} added successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Error: Failed to add subnet: {e}")
            logger.error(f"Failed to add subnet: {e}")
            self.net.delete_namespace(namespace)
            self.net.delete_veth(veth_host)
            return False
    
    def delete_subnet(self, vpc_name, subnet_name):
        """Delete subnet from VPC"""
        print(f"\n{'='*80}")
        print(f"DELETING SUBNET: {subnet_name} from VPC: {vpc_name}")
        print(f"{'='*80}")
        logger.info(f"Deleting subnet {subnet_name} from VPC {vpc_name}")
        
        vpc = self.state.get_vpc(vpc_name)
        if not vpc:
            print(f"‚ùå Error: VPC '{vpc_name}' not found")
            return False
        
        if subnet_name not in vpc["subnets"]:
            print(f"‚ùå Error: Subnet '{subnet_name}' not found")
            return False
        
        subnet = vpc["subnets"][subnet_name]
        
        try:
            # Remove NAT if public
            if subnet["type"] == "public" and subnet.get("out_interface"):
                self.net.remove_nat(subnet["cidr"], subnet["out_interface"])
            
            # Delete namespace
            self.net.delete_namespace(subnet["namespace"])
            
            # Delete veth
            self.net.delete_veth(subnet["veth_host"])
            
            # Remove from state
            del vpc["subnets"][subnet_name]
            self.state.update_vpc(vpc_name, vpc)
            
            print(f"\n‚úÖ Subnet '{subnet_name}' deleted successfully!")
            logger.info(f"Subnet {subnet_name} deleted")
            return True
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            logger.error(f"Failed to delete subnet: {e}")
            return False
    
    def delete_vpc(self, vpc_name):
        """Delete VPC and all its resources"""
        print(f"\n{'='*80}")
        print(f"DELETING VPC: {vpc_name}")
        print(f"{'='*80}")
        logger.info(f"Deleting VPC: {vpc_name}")
        
        vpc = self.state.get_vpc(vpc_name)
        if not vpc:
            print(f"‚ùå Error: VPC '{vpc_name}' not found")
            logger.error(f"VPC {vpc_name} not found")
            return False
        
        try:
            # Delete all subnets
            for subnet_name, subnet in list(vpc["subnets"].items()):
                logger.info(f"Deleting subnet {subnet_name}")
                
                if subnet["type"] == "public" and subnet.get("out_interface"):
                    self.net.remove_nat(subnet["cidr"], subnet["out_interface"])
                
                self.net.delete_namespace(subnet["namespace"])
                self.net.delete_veth(subnet["veth_host"])
            
            # Delete peerings
            for peering in vpc.get("peerings", []):
                logger.info(f"Removing peering with {peering.get('peer_vpc')}")
                self.net.delete_veth(peering.get("veth_local", ""))
                # Remove host routes
                peer_vpc = self.state.get_vpc(peering.get("peer_vpc", ""))
                if peer_vpc:
                    self.net.delete_host_route(peer_vpc["cidr_block"])
                print(f"  ‚úì Removed peering with {peering.get('peer_vpc')}")
            
            # Delete bridge
            self.net.delete_bridge(vpc["bridge"])
            
            # Remove from state
            self.state.remove_vpc(vpc_name)
            
            print(f"\n‚úÖ VPC '{vpc_name}' deleted successfully!")
            logger.info(f"VPC {vpc_name} deleted successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Error: Failed to delete VPC: {e}")
            logger.error(f"Failed to delete VPC: {e}")
            return False
    
    def peer_vpcs(self, vpc1_name, vpc2_name):
        """
        Create VPC peering connection
        
        Peering implementation:
        - veth pair connects the two VPC bridges
        - Host routes direct traffic between VPCs
        - Allows controlled communication between isolated VPCs
        """
        print(f"\n{'='*80}")
        print(f"CREATING VPC PEERING: {vpc1_name} <-> {vpc2_name}")
        print(f"{'='*80}")
        logger.info(f"Creating peering between {vpc1_name} and {vpc2_name}")
        
        vpc1 = self.state.get_vpc(vpc1_name)
        vpc2 = self.state.get_vpc(vpc2_name)
        
        if not vpc1 or not vpc2:
            print(f"‚ùå Error: One or both VPCs not found")
            logger.error("One or both VPCs not found")
            return False
        
        # Check for CIDR overlap
        net1 = ipaddress.ip_network(vpc1["cidr_block"])
        net2 = ipaddress.ip_network(vpc2["cidr_block"])
        
        if net1.overlaps(net2):
            print(f"‚ùå Error: VPC CIDR blocks overlap - peering not possible")
            logger.error("VPC CIDR blocks overlap")
            return False
        
        # Check if peering already exists
        for peering in vpc1.get("peerings", []):
            if peering.get("peer_vpc") == vpc2_name:
                print(f"‚ùå Error: Peering already exists")
                logger.error("Peering already exists")
                return False
        
        veth1 = f"peer-{vpc1_name}-{vpc2_name}"
        veth2 = f"peer-{vpc2_name}-{vpc1_name}"
        
        try:
            # Create veth pair
            self.net.create_veth_pair(veth1, veth2)
            
            # Attach to bridges
            self.net.attach_to_bridge(veth1, vpc1["bridge"])
            self.net.attach_to_bridge(veth2, vpc2["bridge"])
            print(f"  ‚úì Attached veth pair to bridges")
            
            # Add host routes (with existence check)
            self.net.add_host_route(vpc2["cidr_block"], vpc1["bridge"])
            self.net.add_host_route(vpc1["cidr_block"], vpc2["bridge"])
            print(f"  ‚úì Added routing entries")
            
            # Update state
            peering_info1 = {
                "peer_vpc": vpc2_name,
                "veth_local": veth1,
                "veth_remote": veth2,
                "created_at": datetime.now().isoformat()
            }
            vpc1.setdefault("peerings", []).append(peering_info1)
            
            peering_info2 = {
                "peer_vpc": vpc1_name,
                "veth_local": veth2,
                "veth_remote": veth1,
                "created_at": datetime.now().isoformat()
            }
            vpc2.setdefault("peerings", []).append(peering_info2)
            
            self.state.update_vpc(vpc1_name, vpc1)
            self.state.update_vpc(vpc2_name, vpc2)
            
            print(f"\n‚úÖ VPC peering established successfully!")
            print(f"   {vpc1_name} ({vpc1['cidr_block']}) <-> {vpc2_name} ({vpc2['cidr_block']})")
            logger.info(f"Peering established between {vpc1_name} and {vpc2_name}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error: Failed to create peering: {e}")
            logger.error(f"Failed to create peering: {e}")
            self.net.delete_veth(veth1)
            return False
    
    def unpeer_vpcs(self, vpc1_name, vpc2_name):
        """Delete VPC peering connection"""
        print(f"\n{'='*80}")
        print(f"DELETING VPC PEERING: {vpc1_name} <-> {vpc2_name}")
        print(f"{'='*80}")
        logger.info(f"Deleting peering between {vpc1_name} and {vpc2_name}")
        
        vpc1 = self.state.get_vpc(vpc1_name)
        vpc2 = self.state.get_vpc(vpc2_name)
        
        if not vpc1 or not vpc2:
            print(f"‚ùå Error: One or both VPCs not found")
            return False
        
        # Find peering
        peering1 = None
        for p in vpc1.get("peerings", []):
            if p.get("peer_vpc") == vpc2_name:
                peering1 = p
                break
        
        if not peering1:
            print(f"‚ùå Error: No peering found")
            return False
        
        try:
            # Delete veth pair
            self.net.delete_veth(peering1["veth_local"])
            print(f"  ‚úì Deleted veth pair")
            
            # Remove host routes
            self.net.delete_host_route(vpc2["cidr_block"])
            self.net.delete_host_route(vpc1["cidr_block"])
            print(f"  ‚úì Removed routing entries")
            
            # Update state
            vpc1["peerings"] = [p for p in vpc1.get("peerings", []) if p.get("peer_vpc") != vpc2_name]
            vpc2["peerings"] = [p for p in vpc2.get("peerings", []) if p.get("peer_vpc") != vpc1_name]
            
            self.state.update_vpc(vpc1_name, vpc1)
            self.state.update_vpc(vpc2_name, vpc2)
            
            print(f"\n‚úÖ VPC peering deleted successfully!")
            logger.info(f"Peering deleted between {vpc1_name} and {vpc2_name}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error: Failed to delete peering: {e}")
            logger.error(f"Failed to delete peering: {e}")
            return False
    
    def apply_security_group(self, vpc_name, subnet_name, policy_file):
        """
        Apply security group rules from JSON policy file
        
        Security groups control inbound/outbound traffic using iptables
        """
        print(f"\n{'='*80}")
        print(f"APPLYING SECURITY GROUP")
        print(f"{'='*80}")
        logger.info(f"Applying security group to {vpc_name}/{subnet_name}")
        
        vpc = self.state.get_vpc(vpc_name)
        if not vpc:
            print(f"‚ùå Error: VPC '{vpc_name}' not found")
            return False
        
        subnet = vpc["subnets"].get(subnet_name)
        if not subnet:
            print(f"‚ùå Error: Subnet '{subnet_name}' not found")
            return False
        
        try:
            with open(policy_file, 'r') as f:
                policy = json.load(f)
            
            namespace = subnet["namespace"]
            
            # Apply ingress rules
            for rule in policy.get("ingress", []):
                self.net.apply_firewall_rule(namespace, rule)
            
            print(f"\n‚úÖ Security group applied successfully!")
            print(f"   VPC: {vpc_name}")
            print(f"   Subnet: {subnet_name}")
            print(f"   Rules: {len(policy.get('ingress', []))}")
            logger.info(f"Security group applied to {subnet_name}")
            return True
            
        except FileNotFoundError:
            print(f"‚ùå Error: Policy file '{policy_file}' not found")
            return False
        except json.JSONDecodeError as e:
            print(f"‚ùå Error: Invalid JSON: {e}")
            return False
        except Exception as e:
            print(f"‚ùå Error: Failed to apply security group: {e}")
            return False
    
    def deploy_app(self, vpc_name, subnet_name, app_type="python", port=8000):
        """Deploy test application in subnet"""
        print(f"\n{'='*80}")
        print(f"DEPLOYING APPLICATION")
        print(f"{'='*80}")
        logger.info(f"Deploying {app_type} in {vpc_name}/{subnet_name}")
        
        vpc = self.state.get_vpc(vpc_name)
        if not vpc:
            print(f"‚ùå Error: VPC '{vpc_name}' not found")
            return False
        
        subnet = vpc["subnets"].get(subnet_name)
        if not subnet:
            print(f"‚ùå Error: Subnet '{subnet_name}' not found")
            return False
        
        namespace = subnet["namespace"]
        
        try:
            if app_type == "python":
                # Create HTML content
                html_content = f"""<!DOCTYPE html>
<html>
<head><title>VPC Test App</title></head>
<body style="font-family: Arial; padding: 40px; background: #f0f0f0;">
    <h1>‚úÖ VPC Test Application</h1>
    <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <h2>VPC: {vpc_name}</h2>
        <h3>Subnet: {subnet_name}</h3>
        <p><strong>IP Address:</strong> {subnet['ip']}</p>
        <p><strong>Subnet Type:</strong> {subnet['type']}</p>
        <p><strong>CIDR:</strong> {subnet['cidr']}</p>
        <p><strong>Timestamp:</strong> {datetime.now().isoformat()}</p>
    </div>
    <p style="margin-top: 20px; color: #666;">
        Running in namespace: {namespace}
    </p>
</body>
</html>"""
                
                # Create temp directory
                temp_dir = f"/tmp/vpcctl_{namespace}"
                os.makedirs(temp_dir, exist_ok=True)
                
                with open(f"{temp_dir}/index.html", 'w') as f:
                    f.write(html_content)
                
                # Start HTTP server in background
                cmd = f"ip netns exec {namespace} python3 -m http.server {port} --directory {temp_dir} > /dev/null 2>&1 &"
                subprocess.Popen(cmd, shell=True)
                
                print(f"  ‚úì Python HTTP server started")
            
            # Update subnet state
            subnet["app"] = {
                "type": app_type,
                "port": port,
                "deployed_at": datetime.now().isoformat()
            }
            self.state.update_vpc(vpc_name, vpc)
            
            print(f"\n‚úÖ Application deployed successfully!")
            print(f"   Type: {app_type}")
            print(f"   IP: {subnet['ip']}")
            print(f"   Port: {port}")
            print(f"   URL: http://{subnet['ip']}:{port}")
            print(f"\n   Test from host:")
            print(f"   curl http://{subnet['ip']}:{port}")
            
            logger.info(f"{app_type} deployed on {subnet['ip']}:{port}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error: Failed to deploy app: {e}")
            logger.error(f"Failed to deploy app: {e}")
            return False
    
    def list_vpcs(self):
        """List all VPCs with details"""
        vpcs = self.state.list_vpcs()
        
        if not vpcs:
            print("\nüìã No VPCs found")
            print("   Create your first VPC with:")
            print("   sudo ./vpcctl create-vpc --name myvpc --cidr 10.0.0.0/16")
            return
        
        print(f"\n{'='*80}")
        print("VPC LIST")
        print(f"{'='*80}\n")
        
        for vpc_name, vpc in vpcs.items():
            print(f"üì¶ VPC: {vpc_name}")
            print(f"   CIDR Block: {vpc['cidr_block']}")
            print(f"   Bridge: {vpc['bridge']}")
            print(f"   Gateway IP: {vpc['bridge_ip']}")
            print(f"   Created: {vpc['created_at']}")
            print(f"   Subnets: {len(vpc['subnets'])}")
            
            if vpc["subnets"]:
                for name, subnet in vpc["subnets"].items():
                    icon = "üåê" if subnet['type'] == 'public' else "üîí"
                    print(f"      {icon} {name}")
                    print(f"         CIDR: {subnet['cidr']}")
                    print(f"         Type: {subnet['type']}")
                    print(f"         IP: {subnet['ip']}")
                    print(f"         Namespace: {subnet['namespace']}")
                    if subnet.get('app'):
                        print(f"         App: {subnet['app']['type']} on port {subnet['app']['port']}")
            
            if vpc.get("peerings"):
                print(f"   Peerings: {len(vpc['peerings'])}")
                for peering in vpc['peerings']:
                    print(f"      ‚Üî {peering['peer_vpc']}")
            
            print()
        
        print(f"{'='*80}\n")
    
    def show_vpc(self, vpc_name):
        """Show detailed VPC information"""
        vpc = self.state.get_vpc(vpc_name)
        
        if not vpc:
            print(f"‚ùå Error: VPC '{vpc_name}' not found")
            return False
        
        print(f"\n{'='*80}")
        print(f"VPC DETAILS: {vpc_name}")
        print(f"{'='*80}\n")
        
        print(f"Name: {vpc['name']}")
        print(f"CIDR Block: {vpc['cidr_block']}")
        print(f"Bridge: {vpc['bridge']}")
        print(f"Gateway IP: {vpc['bridge_ip']}")
        print(f"Created: {vpc['created_at']}")
        
        print(f"\nüìä Subnets ({len(vpc['subnets'])}):")
        if vpc["subnets"]:
            for name, subnet in vpc["subnets"].items():
                print(f"\n  ‚Ä¢ {name}")
                print(f"    CIDR: {subnet['cidr']}")
                print(f"    Type: {subnet['type']}")
                print(f"    IP: {subnet['ip']}")
                print(f"    Gateway: {subnet['bridge_ip']}")
                print(f"    Namespace: {subnet['namespace']}")
                print(f"    Veth Pair: {subnet['veth_host']} <-> {subnet['veth_ns']}")
                if subnet.get('app'):
                    print(f"    App: {subnet['app']['type']} on port {subnet['app']['port']}")
        else:
            print("    No subnets")
        
        print(f"\nüîó Peerings ({len(vpc.get('peerings', []))}):")
        if vpc.get("peerings"):
            for peering in vpc['peerings']:
                print(f"  ‚Ä¢ {peering['peer_vpc']}")
                print(f"    Veth: {peering['veth_local']} <-> {peering['veth_remote']}")
                print(f"    Created: {peering['created_at']}")
        else:
            print("    No peerings")
        
        print(f"\n{'='*80}\n")
        return True
    
    def get_default_interface(self):
        """Get default network interface for internet access"""
        try:
            result = self.net.run_command(["ip", "route", "show", "default"])
            if result and result.stdout:
                parts = result.stdout.split()
                if "dev" in parts:
                    iface = parts[parts.index("dev") + 1]
                    logger.info(f"Default interface: {iface}")
                    return iface
        except:
            pass
        
        # Fallback to common interface names
        for iface in ["eth0", "ens33", "enp0s3", "wlan0", "wlp2s0", "ens5"]:
            result = self.net.run_command(["ip", "link", "show", iface], check=False)
            if result and result.returncode == 0:
                logger.info(f"Using interface: {iface}")
                return iface
        
        logger.warning("Could not detect default interface, using eth0")
        return "eth0"


def main():
    """Main CLI entry point"""
    
    # Check root privileges
    if os.geteuid() != 0:
        print("\n‚ùå Error: This script must be run as root")
        print("   Please run with: sudo ./vpcctl <command>\n")
        sys.exit(1)
    
    parser = argparse.ArgumentParser(
        description="vpcctl - Virtual Private Cloud Control Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Create VPC:
    sudo ./vpcctl create-vpc --name myvpc --cidr 10.0.0.0/16
  
  Add public subnet:
    sudo ./vpcctl add-subnet --vpc myvpc --name public1 --cidr 10.0.1.0/24 --type public
  
  Add private subnet:
    sudo ./vpcctl add-subnet --vpc myvpc --name private1 --cidr 10.0.2.0/24 --type private
  
  List VPCs:
    sudo ./vpcctl list
  
  Show VPC details:
    sudo ./vpcctl show-vpc --name myvpc
  
  Peer VPCs:
    sudo ./vpcctl peer-vpcs --vpc1 myvpc --vpc2 othervpc
  
  Unpeer VPCs:
    sudo ./vpcctl unpeer-vpcs --vpc1 myvpc --vpc2 othervpc
  
  Apply firewall:
    sudo ./vpcctl apply-policy --vpc myvpc --subnet public1 --policy rules.json
  
  Deploy app:
    sudo ./vpcctl deploy-app --vpc myvpc --subnet public1 --port 8000
  
  Delete subnet:
    sudo ./vpcctl delete-subnet --vpc myvpc --name public1
  
  Delete VPC:
    sudo ./vpcctl delete-vpc --name myvpc
  
  Cleanup all:
    sudo ./vpcctl cleanup-all
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    # Create VPC
    create_parser = subparsers.add_parser('create-vpc', help='Create a new VPC')
    create_parser.add_argument('--name', required=True, help='VPC name')
    create_parser.add_argument('--cidr', required=True, help='CIDR block (e.g., 10.0.0.0/16)')
    
    # Add Subnet
    subnet_parser = subparsers.add_parser('add-subnet', help='Add subnet to VPC')
    subnet_parser.add_argument('--vpc', required=True, help='VPC name')
    subnet_parser.add_argument('--name', required=True, help='Subnet name')
    subnet_parser.add_argument('--cidr', required=True, help='Subnet CIDR')
    subnet_parser.add_argument('--type', choices=['public', 'private'], default='private', help='Subnet type')
    
    # Delete Subnet
    del_subnet_parser = subparsers.add_parser('delete-subnet', help='Delete subnet from VPC')
    del_subnet_parser.add_argument('--vpc', required=True, help='VPC name')
    del_subnet_parser.add_argument('--name', required=True, help='Subnet name')
    
    # Delete VPC
    delete_parser = subparsers.add_parser('delete-vpc', help='Delete VPC')
    delete_parser.add_argument('--name', required=True, help='VPC name')
    
    # Peer VPCs
    peer_parser = subparsers.add_parser('peer-vpcs', help='Create VPC peering')
    peer_parser.add_argument('--vpc1', required=True, help='First VPC name')
    peer_parser.add_argument('--vpc2', required=True, help='Second VPC name')
    
    # Unpeer VPCs
    unpeer_parser = subparsers.add_parser('unpeer-vpcs', help='Delete VPC peering')
    unpeer_parser.add_argument('--vpc1', required=True, help='First VPC name')
    unpeer_parser.add_argument('--vpc2', required=True, help='Second VPC name')
    
    # Apply Policy
    policy_parser = subparsers.add_parser('apply-policy', help='Apply security group policy')
    policy_parser.add_argument('--vpc', required=True, help='VPC name')
    policy_parser.add_argument('--subnet', required=True, help='Subnet name')
    policy_parser.add_argument('--policy', required=True, help='Policy JSON file')
    
    # Deploy App
    deploy_parser = subparsers.add_parser('deploy-app', help='Deploy test application')
    deploy_parser.add_argument('--vpc', required=True, help='VPC name')
    deploy_parser.add_argument('--subnet', required=True, help='Subnet name')
    deploy_parser.add_argument('--type', default='python', help='App type (python)')
    deploy_parser.add_argument('--port', type=int, default=8000, help='Port number')
    
    # List VPCs
    list_parser = subparsers.add_parser('list', help='List all VPCs')
    
    # Show VPC
    show_parser = subparsers.add_parser('show-vpc', help='Show VPC details')
    show_parser.add_argument('--name', required=True, help='VPC name')
    
    # Cleanup all
    cleanup_parser = subparsers.add_parser('cleanup-all', help='Delete all VPCs')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    manager = VPCManager()
    
    try:
        if args.command == 'create-vpc':
            success = manager.create_vpc(args.name, args.cidr)
            sys.exit(0 if success else 1)
            
        elif args.command == 'add-subnet':
            success = manager.add_subnet(args.vpc, args.name, args.cidr, args.type)
            sys.exit(0 if success else 1)
            
        elif args.command == 'delete-subnet':
            success = manager.delete_subnet(args.vpc, args.name)
            sys.exit(0 if success else 1)
            
        elif args.command == 'delete-vpc':
            success = manager.delete_vpc(args.name)
            sys.exit(0 if success else 1)
            
        elif args.command == 'peer-vpcs':
            success = manager.peer_vpcs(args.vpc1, args.vpc2)
            sys.exit(0 if success else 1)
            
        elif args.command == 'unpeer-vpcs':
            success = manager.unpeer_vpcs(args.vpc1, args.vpc2)
            sys.exit(0 if success else 1)
            
        elif args.command == 'apply-policy':
            success = manager.apply_security_group(args.vpc, args.subnet, args.policy)
            sys.exit(0 if success else 1)
            
        elif args.command == 'deploy-app':
            success = manager.deploy_app(args.vpc, args.subnet, args.type, args.port)
            sys.exit(0 if success else 1)
            
        elif args.command == 'list':
            manager.list_vpcs()
            
        elif args.command == 'show-vpc':
            success = manager.show_vpc(args.name)
            sys.exit(0 if success else 1)
            
        elif args.command == 'cleanup-all':
            print("\n‚ö†Ô∏è  WARNING: This will delete ALL VPCs!")
            response = input("Are you sure? (yes/no): ")
            if response.lower() == 'yes':
                vpcs = list(manager.state.list_vpcs().keys())
                for vpc_name in vpcs:
                    manager.delete_vpc(vpc_name)
                print("\n‚úÖ All VPCs cleaned up")
            else:
                print("Operation cancelled")
            
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Operation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}")
        logger.error(f"Unexpected error: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()